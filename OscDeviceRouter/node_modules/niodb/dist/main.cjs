'use strict';

const node_fs = require('node:fs');
const promises = require('node:fs/promises');
const path = require('node:path');

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DataOp {
  /**
   * Initialize a new object of wrapper methods.
   */
  /**
   * @param {Proxy} proxy Object that needs the wrapper methods
   */
  constructor(proxy) {
    __publicField(this, "proxy");
    this.proxy = proxy;
  }
  /**
   * Return the value of a key
   */
  /**
   * @param {string} key
   * @returns value
   */
  $get(key) {
    return this.proxy[key];
  }
  /**
   * Set a key to hold a value
   */
  /**
   * @param {string} key
   * @param {any} val
   * @returns Proxy
   */
  $set(key, val) {
    this.proxy[key] = val;
    return this.proxy;
  }
  /**
   * Delete a key
   */
  /**
   * @param {string} key
   * @returns Proxy
   */
  $delete(key) {
    delete this.proxy[key];
    return this.proxy;
  }
  /**
   * If the key exists
   */
  /**
   * @param {string} key
   * @returns If key exists
   */
  $exists(key) {
    return key in this.proxy;
  }
  /**
   * Return a random key
   */
  /**
   * @returns a random key
   */
  $randomKey() {
    const keys = Object.keys(this.proxy);
    return keys[parseInt(Math.random() * keys.length)];
  }
  /**
   * Rename a key to a new key
   */
  /**
   * @param {string} key
   * @param {string} newKey
   * @returns Proxy
   */
  $rename(key, newKey) {
    if (this.$exists(key)) {
      this.$set(newKey, this.$get(key));
      this.$delete(key);
    }
    return this.proxy;
  }
  /**
   * Return the type of the value stored in a key
   * Possible values: string, number, boolean, object, array, null, undefined
   */
  /**
   * @param {string} key
   * @returns type of the value stored in a key
   */
  $type(key) {
    const data = this.proxy[key];
    if (Array.isArray(data))
      return "array";
    if (data === null)
      return "null";
    return typeof data;
  }
}

class DatabaseError extends Error {
  /**
   * Initialize a DatabaseError.
   *
   * @api public
   */
  /**
   * @param {...any} args Any parameters of Error class
   */
  constructor(...args) {
    super(...args);
    this.name = "DatabaseError";
  }
}

async function loadDataFromFile(proxy, filepath) {
  try {
    if (node_fs.existsSync(filepath)) {
      const data = JSON.parse(await promises.readFile(filepath, { encoding: "utf8" }));
      for (const key in data) {
        proxy[key] = data[key];
      }
    }
  } catch (err) {
    throw new DatabaseError("Reading and parsing file " + filepath + " failed. " + err.message);
  }
}

async function writeDataToFile(proxy, filepath) {
  try {
    const data = JSON.stringify(proxy);
    const tempFilePath = path__namespace.format({
      ...path__namespace.parse(filepath),
      base: void 0,
      ext: ".nio.tmp"
    });
    await promises.writeFile(tempFilePath, data);
    await promises.rename(tempFilePath, filepath);
  } catch (err) {
    throw new DatabaseError("Writing file " + filepath + " failed. " + err.message);
  }
}

function getValidDataType(data) {
  if (data === void 0) {
    return {
      isValid: false
    };
  }
  if (typeof data === "string" || typeof data === "number" || typeof data === "boolean" || data === null) {
    return {
      isValid: true,
      data
    };
  }
  if (data instanceof String) {
    return {
      isValid: true,
      data: data.toString()
    };
  }
  if (data instanceof Number) {
    if (Number.isFinite(data.valueOf())) {
      data = data.valueOf();
    } else {
      data = null;
    }
    return {
      isValid: true,
      data
    };
  }
  if (data instanceof Boolean) {
    return {
      isValid: true,
      data: data.valueOf()
    };
  }
  if (data instanceof Set) {
    data = Array.from(data);
  }
  if (data instanceof Map) {
    data = Object.fromEntries(data);
  }
  if (Array.isArray(data)) {
    const newData = [];
    for (const i in data) {
      const validDataTypeObj = getValidDataType(data[i]);
      if (!validDataTypeObj.isValid) {
        return {
          isValid: false
        };
      }
      newData[i] = validDataTypeObj.data;
    }
    return {
      isValid: true,
      data: newData
    };
  }
  if (typeof data === "object") {
    const newData = {};
    for (const key in data) {
      const validDataTypeObj = getValidDataType(data[key]);
      if (!validDataTypeObj.isValid) {
        return {
          isValid: false
        };
      }
      newData[key] = validDataTypeObj.data;
    }
    return {
      isValid: true,
      data: newData
    };
  }
  return {
    isValid: false
  };
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _filepath, _config, _isFileDatabase, _isDataLoaded, _isUpdaterActive, _bindProxy, bindProxy_fn, _dataFileUpdater, dataFileUpdater_fn;
class Nio {
  /**
   * Initialize a new Nio database.
   *
   * @api public
   */
  /**
   * @param {string} filepath Path of a json file
   * @param {object} config Database config
   * @param {function} config.transactionUpdated Callback function when the data file has been updated
   * @returns {Promise, Nio} Returns a Promise object when filepath is defined, otherwise returns a Nio instance
   */
  constructor(filepath, config) {
    /**
     * Create a proxy for Nio instance and objects within the instance.
     */
    /**
     * @param {object} obj Object that wants to proxy
     * @returns Proxy of the object
     */
    __privateAdd(this, _bindProxy);
    /**
     * Store data in memory to the file asynchronously
     */
    __privateAdd(this, _dataFileUpdater);
    __privateAdd(this, _filepath, void 0);
    __privateAdd(this, _config, void 0);
    __privateAdd(this, _isFileDatabase, void 0);
    __privateAdd(this, _isDataLoaded, void 0);
    __privateAdd(this, _isUpdaterActive, void 0);
    __privateSet(this, _filepath, filepath);
    __privateSet(this, _config, config);
    __privateSet(this, _isFileDatabase, true);
    __privateSet(this, _isDataLoaded, false);
    __privateSet(this, _isUpdaterActive, false);
    if (__privateGet(this, _filepath) === void 0 || __privateGet(this, _filepath) === null || !__privateGet(this, _filepath)) {
      __privateSet(this, _isFileDatabase, false);
    }
    if (typeof config !== "object") {
      __privateSet(this, _config, {});
    }
    const proxy = __privateMethod(this, _bindProxy, bindProxy_fn).call(this, this);
    if (__privateGet(this, _isFileDatabase)) {
      return new Promise((resolve, reject) => {
        loadDataFromFile(proxy, __privateGet(this, _filepath)).then(() => {
          __privateSet(this, _isDataLoaded, true);
          resolve(proxy);
        }).catch((err) => {
          reject(err);
        });
      });
    }
    __privateSet(this, _isDataLoaded, true);
    return proxy;
  }
}
_filepath = new WeakMap();
_config = new WeakMap();
_isFileDatabase = new WeakMap();
_isDataLoaded = new WeakMap();
_isUpdaterActive = new WeakMap();
_bindProxy = new WeakSet();
bindProxy_fn = function(obj) {
  const proxy = new Proxy(obj, {
    get: (target, key) => {
      key = key.toString();
      if (obj[key] instanceof Object)
        return __privateMethod(this, _bindProxy, bindProxy_fn).call(this, obj[key]);
      if (!(key in obj) && key in operation) {
        return operation[key];
      }
      return obj[key];
    },
    set: (target, key, val, receiver) => {
      key = key.toString();
      const dataTypeCheckObj = getValidDataType(val);
      if (!dataTypeCheckObj.isValid) {
        throw new TypeError('Cannot set "' + key + '" to "' + val + '", because it is not a valid data type.');
      }
      val = dataTypeCheckObj.data;
      Reflect.set(target, key, val, receiver);
      __privateMethod(this, _dataFileUpdater, dataFileUpdater_fn).call(this);
      return true;
    },
    deleteProperty: (target, key) => {
      key = key.toString();
      Reflect.deleteProperty(target, key);
      __privateMethod(this, _dataFileUpdater, dataFileUpdater_fn).call(this);
      return true;
    }
  });
  const operation = new DataOp(proxy);
  return proxy;
};
_dataFileUpdater = new WeakSet();
dataFileUpdater_fn = function() {
  if (__privateGet(this, _isUpdaterActive) || !__privateGet(this, _isFileDatabase) || !__privateGet(this, _isDataLoaded))
    return;
  new Promise((resolve) => {
    __privateSet(this, _isUpdaterActive, true);
    resolve();
  }).then(async () => {
    await writeDataToFile(this, __privateGet(this, _filepath));
    if (typeof __privateGet(this, _config).transactionUpdated === "function") {
      __privateGet(this, _config).transactionUpdated();
    }
    __privateSet(this, _isUpdaterActive, false);
  });
};

exports.DatabaseError = DatabaseError;
exports.Nio = Nio;
